import chai = require('chai');
const assert = chai.assert;
import parquet_codec_plain = require('../src/codec/plain');
import assert_util = require('./assert_util');
import { ParquetValueArray, PrimitiveType } from '../src';

const testEncode = (
  type: PrimitiveType,
  values: ParquetValueArray,
  expectedBytes: number[]
) => {
  const buf = parquet_codec_plain.encodeValues(type, values);
  assert.deepEqual(buf, Buffer.from(expectedBytes));
  const decoded = parquet_codec_plain.decodeValues(
    type,
    { offset: 0, buffer: buf, size: buf.length },
    values.length,
    {}
  );
  // Decoded values should match the encoded values
  // Values might come back as a type array; convert to JS array before comparing
  assert.deepEqual(values as any[], Array.from(decoded as any));
};

// tslint:disable:ter-prefer-arrow-callback
describe('ParquetCodec::PLAIN', function () {
  it('should encode BOOLEAN values', function () {
    testEncode(
      'BOOLEAN',
      [true, false, true, true, false, true, false, false],
      [0x2d]
    ); // b101101
  });

  it('should decode BOOLEAN values', function () {
    const buf = {
      offset: 0,
      buffer: Buffer.from([0x2d]), // b101101
    };

    const vals = parquet_codec_plain.decodeValues('BOOLEAN', buf, 8, {});
    assert.equal(buf.offset, 1);
    assert.deepEqual(vals, [
      true,
      false,
      true,
      true,
      false,
      true,
      false,
      false,
    ]);
  });

  it('should encode INT32 values', function () {
    testEncode(
      'INT32',
      [42, 17, 23, -1, -2, -3, 9000, 420],
      // prettier-ignore
      [
        0x2a, 0x00, 0x00, 0x00, // 42
        0x11, 0x00, 0x00, 0x00, // 17
        0x17, 0x00, 0x00, 0x00, // 23
        0xff, 0xff, 0xff, 0xff, // -1
        0xfe, 0xff, 0xff, 0xff, // -2
        0xfd, 0xff, 0xff, 0xff, // -3
        0x28, 0x23, 0x00, 0x00, // 9000
        0xa4, 0x01, 0x00, 0x00  // 420
      ]
    );
  });

  it('should decode INT32 values', function () {
    const buf = {
      offset: 0,
      buffer: Buffer.from(
        // prettier-ignore
        [
          0x2a, 0x00, 0x00, 0x00, // 42
          0x11, 0x00, 0x00, 0x00, // 17
          0x17, 0x00, 0x00, 0x00, // 23
          0xff, 0xff, 0xff, 0xff, // -1
          0xfe, 0xff, 0xff, 0xff, // -2
          0xfd, 0xff, 0xff, 0xff, // -3
          0x28, 0x23, 0x00, 0x00, // 9000
          0xa4, 0x01, 0x00, 0x00  // 420
        ]
      ),
    };

    const vals = parquet_codec_plain.decodeValues('INT32', buf, 8, {});
    assert.equal(buf.offset, 32);
    assert.deepEqual(vals, new Int32Array([42, 17, 23, -1, -2, -3, 9000, 420]));
  });

  it('should decode INT32 values that are not 4-byte aligned', function () {
    const buf = {
      offset: 1,
      buffer: Buffer.from(
        // prettier-ignore
        [
          0, // Padding
          0x2a, 0x00, 0x00, 0x00, // 42
          0x11, 0x00, 0x00, 0x00, // 17
          0x17, 0x00, 0x00, 0x00, // 23
          0xff, 0xff, 0xff, 0xff, // -1
          0xfe, 0xff, 0xff, 0xff, // -2
          0xfd, 0xff, 0xff, 0xff, // -3
          0x28, 0x23, 0x00, 0x00, // 9000
          0xa4, 0x01, 0x00, 0x00  // 420
        ]
      ),
    };

    const vals = parquet_codec_plain.decodeValues('INT32', buf, 8, {});
    assert.equal(buf.offset, 33);
    assert.deepEqual(vals, new Int32Array([42, 17, 23, -1, -2, -3, 9000, 420]));
  });

  it('should encode INT64 values', function () {
    testEncode(
      'INT64',
      [42, 17, 23, -1, -2, -3, 9000, 420],
      // prettier-ignore
      [
        0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 17
        0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 23
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -1
        0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -2
        0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -3
        0x28, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 9000
        0xa4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // 420
      ]
    );
  });

  it('should decode INT64 values', function () {
    const buf = {
      offset: 0,
      buffer: Buffer.from(
        // prettier-ignore
        [
          0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
          0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 17
          0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 23
          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -1
          0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -2
          0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -3
          0x28, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 9000
          0xa4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // 420
        ]
      ),
    };

    const vals = parquet_codec_plain.decodeValues('INT64', buf, 8, {});
    assert.equal(buf.offset, 64);
    assert.deepEqual(vals, [42, 17, 23, -1, -2, -3, 9000, 420]);
  });

  it('should encode INT96 values', function () {
    testEncode(
      'INT96',
      [42, 17, 23, -1, -2, -3, 9000, 420],
      // prettier-ignore
      [
        0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 17
        0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 23
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -1
        0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -2
        0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -3
        0x28, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 9000
        0xa4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // 420
      ]
    );
  });

  it('should decode INT96 values', function () {
    const buf = {
      offset: 0,
      buffer: Buffer.from(
        // prettier-ignore
        [
          0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
          0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 17
          0x17, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 23
          0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -1
          0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -2
          0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, // -3
          0x28, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 9000
          0xa4, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  // 420
        ]
      ),
    };

    const vals = parquet_codec_plain.decodeValues('INT96', buf, 8, {});
    assert.equal(buf.offset, 96);
    assert.deepEqual(vals, [42, 17, 23, -1, -2, -3, 9000, 420]);
  });

  it('should encode FLOAT values', function () {
    testEncode(
      'FLOAT',
      [42.0, 23.5, 17.0, 4.199999809265137, 9000],
      // prettier-ignore
      [
        0x00, 0x00, 0x28, 0x42, // 42.0
        0x00, 0x00, 0xbc, 0x41, // 23.5
        0x00, 0x00, 0x88, 0x41, // 17.0
        0x66, 0x66, 0x86, 0x40, // 4.20
        0x00, 0xa0, 0x0c, 0x46  // 9000
      ]
    );
  });

  it('should decode FLOAT values', function () {
    const buf = {
      offset: 0,
      buffer: Buffer.from(
        // prettier-ignore
        [
          0x00, 0x00, 0x28, 0x42, // 42.0
          0x00, 0x00, 0xbc, 0x41, // 23.5
          0x00, 0x00, 0x88, 0x41, // 17.0
          0x66, 0x66, 0x86, 0x40, // 4.20
          0x00, 0xa0, 0x0c, 0x46  // 9000
        ]
      ),
    };

    const vals = parquet_codec_plain.decodeValues('FLOAT', buf, 5, {});
    assert.equal(buf.offset, 20);
    assert_util.assertArrayEqualEpsilon(vals, [42.0, 23.5, 17.0, 4.2, 9000]);
  });

  it('should decode FLOAT values that are not 4-byte aligned', function () {
    const buf = {
      offset: 1,
      buffer: Buffer.from(
          // prettier-ignore
          [
              0, // padding
            0x00, 0x00, 0x28, 0x42, // 42.0
            0x00, 0x00, 0xbc, 0x41, // 23.5
            0x00, 0x00, 0x88, 0x41, // 17.0
            0x66, 0x66, 0x86, 0x40, // 4.20
            0x00, 0xa0, 0x0c, 0x46  // 9000
          ]
      ),
    };

    const vals = parquet_codec_plain.decodeValues('FLOAT', buf, 5, {});
    assert.equal(buf.offset, 21);
    assert_util.assertArrayEqualEpsilon(vals, [42.0, 23.5, 17.0, 4.2, 9000]);
  });

  it('should encode DOUBLE values', function () {
    testEncode(
      'DOUBLE',
      [42.0, 23.5, 17.0, 4.2, 9000],
      // prettier-ignore
      [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x40, // 42.0
        0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x37, 0x40, // 23.5
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x40, // 17.0
        0xcd, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x10, 0x40, // 4.20
        0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xc1, 0x40  // 9000
      ]
    );
  });

  it('should decode DOUBLE values', function () {
    const buf = {
      offset: 0,
      buffer: Buffer.from(
        // prettier-ignore
        [
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x40, // 42.0
          0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x37, 0x40, // 23.5
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x40, // 17.0
          0xcd, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x10, 0x40, // 4.20
          0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xc1, 0x40  // 9000
        ]
      ),
    };

    const vals = parquet_codec_plain.decodeValues('DOUBLE', buf, 5, {});
    assert.equal(buf.offset, 40);
    assert_util.assertArrayEqualEpsilon(vals, [42.0, 23.5, 17.0, 4.2, 9000]);
  });

  it('should decode DOUBLE values that are not 8-byte aligned', function () {
    const buf = {
      offset: 1,
      buffer: Buffer.from(
          // prettier-ignore
        [
          0, // padding
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x40, // 42.0
          0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x37, 0x40, // 23.5
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x40, // 17.0
          0xcd, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x10, 0x40, // 4.20
          0x00, 0x00, 0x00, 0x00, 0x00, 0x94, 0xc1, 0x40  // 9000
        ]
      ),
    };

    const vals = parquet_codec_plain.decodeValues('DOUBLE', buf, 5, {});
    assert.equal(buf.offset, 41);
    assert_util.assertArrayEqualEpsilon(vals, [42.0, 23.5, 17.0, 4.2, 9000]);
  });

  it('should encode BYTE_ARRAY values', function () {
    testEncode(
      'BYTE_ARRAY',
      ['one', Buffer.from([0xde, 0xad, 0xbe, 0xef]), 'three'],
      // prettier-ignore
      [
        0x03, 0x00, 0x00, 0x00,       // (3)
        0x6f, 0x6e, 0x65,             // 'one'
        0x04, 0x00, 0x00, 0x00,       // (4)
        0xde, 0xad, 0xbe, 0xef,       // 0xdeadbeef
        0x05, 0x00, 0x00, 0x00,       // (5)
        0x74, 0x68, 0x72, 0x65, 0x65  // 'three'
      ]
    );
  });

  it('should decode BYTE_ARRAY values', function () {
    const buf = {
      offset: 0,
      buffer: Buffer.from(
        // prettier-ignore
        [
            0x03, 0x00, 0x00, 0x00,       // (3)
            0x6f, 0x6e, 0x65,             // 'one'
            0x04, 0x00, 0x00, 0x00,       // (4)
            0xde, 0xad, 0xbe, 0xef,       // 0xdeadbeef
            0x05, 0x00, 0x00, 0x00,       // (5)
            0x74, 0x68, 0x72, 0x65, 0x65  // 'three'
          ]
      ),
    };

    const vals = parquet_codec_plain.decodeValues('BYTE_ARRAY', buf, 3, {});
    assert.equal(buf.offset, 24);
    assert.deepEqual(vals, [
      Buffer.from('one'),
      Buffer.from([0xde, 0xad, 0xbe, 0xef]),
      Buffer.from('three'),
    ]);
  });

  it('should encode FIXED_LEN_BYTE_ARRAY values', function () {
    const buf = parquet_codec_plain.encodeValues(
      'FIXED_LEN_BYTE_ARRAY',
      ['oneoo', Buffer.from([0xde, 0xad, 0xbe, 0xef, 0x42]), 'three'],
      {
        typeLength: 5,
      }
    );

    assert.deepEqual(
      buf,
      Buffer.from(
        // prettier-ignore
        [
          0x6f, 0x6e, 0x65, 0x6f, 0x6f, // 'oneoo'
          0xde, 0xad, 0xbe, 0xef, 0x42, // 0xdeadbeef42
          0x74, 0x68, 0x72, 0x65, 0x65  // 'three'
        ]
      )
    );
  });

  it('should decode FIXED_LEN_BYTE_ARRAY values', function () {
    const buf = {
      offset: 0,
      buffer: Buffer.from(
        // prettier-ignore
        [
          0x6f, 0x6e, 0x65, 0x6f, 0x6f, // 'oneoo'
          0xde, 0xad, 0xbe, 0xef, 0x42, // 0xdeadbeef42
          0x74, 0x68, 0x72, 0x65, 0x65  // 'three'
        ]
      ),
    };

    const vals = parquet_codec_plain.decodeValues(
      'FIXED_LEN_BYTE_ARRAY',
      buf,
      3,
      {
        typeLength: 5,
      }
    );

    assert.equal(buf.offset, 15);
    assert.deepEqual(vals, [
      Buffer.from('oneoo'),
      Buffer.from([0xde, 0xad, 0xbe, 0xef, 0x42]),
      Buffer.from('three'),
    ]);
  });
});
